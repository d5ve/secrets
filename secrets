#!/usr/bin/perl

use strict;
use warnings;

=head1 WORK IN PROGRESS

This script currently handles adding/editing/deleting/listing/printing secrets, BUT NO
ENCRYPTION IS DONE YET.

TODO: Encryption of secrets file.

=cut

use Crypt::CBC;
use Data::Dumper;
$Data::Dumper::Sortkeys = 1;
use File::Slurp ();
use File::Spec  ();
use Getopt::Long qw( GetOptions );
use Pod::Usage qw( pod2usage );
use Storable      ();
use Term::ReadKey ();

our $VERSION = '0.010';
$VERSION = eval $VERSION;

my $secrets_file = File::Spec->catfile( $ENV{HOME}, '.secrets' );
my $show_help;
my @valid_actions = qw( list ls add edit delete print );
my @fields        = qw( Name Description Username Password URL Notes );

my $action;

GetOptions(
    'file=s' => \$secrets_file,
    'help|?' => \$show_help,
) or pod2usage();

pod2usage() if $show_help;

$action = shift || pod2usage("Please specify an <action>");
pod2usage() if $action eq 'help';
pod2usage("Invalid <action> '$action'") unless grep { $_ eq $action } @valid_actions;

# list/ls/print operations are read-only
# add/edit/delete operations are read-write

my $master_password = get_master_password();

# Always read the secret data into memory.
my $secrets = read_secrets_from_file( $secrets_file, $master_password );

if ( $action eq 'list' || $action eq 'ls' ) {
    foreach my $canonical_name ( sort keys %{$secrets} ) {
        print "$secrets->{$canonical_name}->{name} :- $secrets->{$canonical_name}->{description}\n";
    }
}
elsif ( $action eq 'add' ) {
    if ( my $new_secret = get_secret_fields( \@fields ) ) {
        if ( $secrets->{ $new_secret->{canonical_name} } ) {
            print "ERROR: $new_secret->{name} already exists. Exiting without saving...\n";
            exit 10;
        }
        $secrets->{ $new_secret->{canonical_name} } = $new_secret;
        write_secrets_to_file( $secrets, $secrets_file, $master_password );
    }
    else {
        print "ERROR: No new secret was added\n";
        exit 20;
    }
}
elsif ( grep { $_ eq $action } (qw( print edit delete )) ) {
    my $secret_name = get_secret_name($action);

    if ( my $chosen_secret = get_secret_by_name( $secret_name, $secrets ) ) {
        if ( $action eq 'print' ) {
            print_secret( $chosen_secret, \@fields );
        }
        elsif ( $action eq 'delete' ) {
            if ( get_user_input("Please confirm deletion by typing 'DELETE $secret_name': ") eq
                "DELETE $secret_name" )
            {
                delete $secrets->{ $chosen_secret->{canonical_name} };
                write_secrets_to_file( $secrets, $secrets_file, $master_password );
                print "'$secret_name' deleted\n";
            }
            else {
                print "No secret was deleted\n";
            }
        }
        elsif ( $action eq 'edit' ) {
            my $edited_secret = get_secret_fields( \@fields, $chosen_secret );
            if ( $edited_secret->{canonical_name} ne $chosen_secret->{canonical_name} ) {

                # Handle potential renaming of the secret.
                delete $chosen_secret->{canonical_name};
            }
            $secrets->{ $edited_secret->{canonical_name} } = $edited_secret;
            write_secrets_to_file( $secrets, $secrets_file, $master_password );
        }
    }
    else {
        print "ERROR: Unable to find a secret named '$secret_name'. Exiting...\n";
        exit 30;
    }
}

exit;

=head1 SUBROUTINES

=cut

=head2 get_master_password( )

Prompt the user for the password to decrypt the secrets file. This is done in
'noecho' mode, so the password doesn't appear on the screen.

Expects:
    None.

Returns:
    String containing the password to decrypt the secrets file.

=cut

sub get_master_password {

    my $master_password = get_user_input( "Please enter master password: ", 'noecho' );

    return $master_password;
}

=head2 print_secret( $secret, $fields )

Prints any set fields of the secret to STDOUT.

Expects:
    A hashref containing the secret data.
    An array ref containing the fields to print.

Returns:
    None.

=cut

sub print_secret {
    my $secret = shift;
    my $fields = shift;

    print "\n$secret->{name}\n", "=" x length( $secret->{name} ), "\n";
    foreach my $field ( @{$fields} ) {
        $secret->{ lc $field } && print "$field: $secret->{lc $field}\n";
    }
    print "\n";
}

=head2 get_secret_by_name( $secret_name, $secrets )

Expects:
    The full name of a secret.
    The set of all secrets.

Returns:
    The secret matching the canonical version of $secret_name if it exists.
    Else undef

=cut

sub get_secret_by_name {
    my $secret_name = shift;
    my $secrets     = shift;

    my $canonical_name = get_canonical_name($secret_name);

    return $secrets->{$canonical_name};
}

=head2 get_secret_name( )

Expects:
    A string representing the action the user is planning.

Returns:
    The name of a secret to operate on.

=cut

sub get_secret_name {
    my $action = shift;

    my $secret_name = get_user_input("Which secret do you wish to $action? ");

    return $secret_name;
}

=head2 get_secret_fields( )

Prompt the user for the required and optional data which make up a secret.

The user will be prompted for the password twice to confirm that they have
typed it correctly, and no output is shown on the screen. The script dies if
the passwords entered are different.

The notes field is a multi-line one, and is ended by a '.' on a line by itself.

This sub is pretty ugly, as it's trying to do ugly things.

Expects:
    An array ref of field names.
    An optional secreti.

Returns:
    Valid secret hash or undef.

=cut

sub get_secret_fields {
    my $fields = shift;
    my $secret = shift || {};

    foreach my $field ( @{$fields} ) {

        # TODO: Look at embedding the mode and multiline stuff
        # into the $fields list itself.
        my $mode      = $field eq 'Password' ? 'noecho' : 'normal';
        my $multiline = $field eq 'Notes'    ? 1        : 0;
        my $confirm   = $field eq 'Password' ? 1        : 0;

        my $new_value;
        my $confirm_value;
        my $old_value = $secret->{ lc $field };;

        if ( defined $old_value ) {

            # Show the previous value, and reuse it if the user just hits enter.
            my $old_value = $field eq 'Password' ? '********' : $secret->{ lc $field };
            if ($multiline) {
                $new_value = get_multiline_user_input( "$field: [\n$old_value\n]", $mode );
                $confirm_value = get_multiline_user_input( "Confirm $field: ", $mode ) if $confirm;
            }
            else {
                $new_value = get_user_input( "$field [$old_value]: ", $mode );
                $confirm_value = get_user_input( "Confirm $field ", $mode ) if $confirm;
            }

        }
        else {

            # No previous value, so just prompt for new value.
            if ($multiline) {
                $new_value = get_multiline_user_input( "$field: ", $mode );
                $confirm_value = get_multiline_user_input( "Confirm $field: ", $mode ) if $confirm;
            }
            else {
                $new_value = get_user_input( "$field: ", $mode );
                $confirm_value = get_user_input( "Confirm $field: ", $mode ) if $confirm;
            }
        }

        # We want to ensure that if a confirmation value was given, that it matches
        # the other value.
        if ( $confirm && defined $new_value && $new_value ne $confirm_value ) {
            die "ERROR: $field values don't match. Exiting without making any changes...\n";
        }

        $secret->{ lc $field } = defined $new_value && length $new_value ? $new_value : $old_value;
    }
    $secret->{canonical_name} = get_canonical_name( $secret->{name} );

    return $secret;
}

=head2 get_canonical_name($name)

Expects:
    Name of a secret.

Returns:
    Lowercased, whitespace-free version of name.

=cut

sub get_canonical_name {
    my $name = shift;

    my $canonical_name = lc $name;
    chomp $canonical_name;
    $canonical_name =~ s{\s+}{_}gxms;

    return $canonical_name;
}

=head2 write_secrets_to_file( $secrets, $secrets_file, $password )

Write the secrets data structure to the secrets file. The data is serialised
then encrypted, then written to disk.

NOTE: This will clobber any existing data in the file, so if you attempt to
write to the file from more then one process simultaneously, the last writer
will win.

TODO: Look at file locking code.

Expects:
    Secrets hash ref.
    Filename to write secrets to.
    Password to encrypt the files contents.

Returns:
    None.

=cut

sub write_secrets_to_file {
    my $secrets      = shift;
    my $secrets_file = shift;
    my $password     = shift;

    my $frozen = Storable::nfreeze($secrets);

    # TODO: Encrypt the frozen data.

    File::Slurp::write_file( $secrets_file, { binmode => ':raw' }, $frozen );
}

=head2 read_secrets_from_file( $secrets_file, $password )

Expects:
    Filename to read secrets from.
    Password to decrypt the files contents.

Returns:
    If everything works (file exists, contains data, password works), then an
    hash ref of secrets.
    Else undef.

=cut

sub read_secrets_from_file {
    my $secrets_file = shift;
    my $password     = shift;

    # Case 1: Non-existant file. This is expected for a first run, or when a
    # new secrets filename is passed in.
    return undef unless -f $secrets_file;

    # Case 2: Existing file
    my $frozen = File::Slurp::read_file($secrets_file);
    return undef unless $frozen;

    # TODO: Decryption
    my $secrets = Storable::thaw($frozen);
    return $secrets;

}

=head2 get_user_input( $prompt, [$mode] ) 

Prompt the user for input, optionally hide what they're typing, and chomp any
string entered.

Expects:
    A textual prompt to print. Can be blank.
    A mode of normal|noecho when reading the input.

Returns:
    A chomped string from STDIN

=cut

sub get_user_input {
    my $prompt = shift || '';
    my $mode   = shift || 'normal';

    print $prompt;
    Term::ReadKey::ReadMode($mode);
    my $input = Term::ReadKey::ReadLine(0);
    Term::ReadKey::ReadMode('normal');
    print "\n" if $mode eq 'noecho';

    chomp $input;
    return $input;
}

=head2 get_multiline_user_input( $prompt, [$mode] ) 

Prompt the user for multiple lines ofinput, optionally hide what they're
typing, and chomp any string entered.

This is a loop around get_user_input().

Expects:
    A textual prompt to print. Can be blank.
    A mode of normal|noecho when reading the input.

Returns:
    A chomped string from STDIN

=cut

sub get_multiline_user_input {
    my $prompt = shift || '';
    my $mode   = shift || 'normal';

    print "$prompt\n(Enter a '.' on a line by itself to end)\n";
    my $input;
    while (1) {
        my $line = get_user_input( '', $mode );
        last if $line eq '.';
        $input .= "$line\n";
    }
    chomp $input if defined $input;
    return $input;
}

__END__
