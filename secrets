#!/usr/bin/perl

use strict;
use warnings;

=head1 WORK IN PROGRESS

This script currently handles adding/deleting/listing/printing secrets, BUT NO
ENCRYPTION IS DONE YET.

TODO: Encryption of secrets file.
TODO: Edit functionality

=cut

use Data::Dumper;
$Data::Dumper::Sortkeys = 1;
use File::Slurp ();
use File::Spec  ();
use Getopt::Long qw( GetOptions );
use Pod::Usage qw( pod2usage );
use Storable      ();
use Term::ReadKey ();

our $VERSION = '0.006';
$VERSION = eval $VERSION;

my $secrets_file = File::Spec->catfile( $ENV{HOME}, '.secrets' );
my $show_help;
my @valid_actions = qw( list ls add edit delete print );

my $action;

GetOptions(
    'file=s' => \$secrets_file,
    'help|?' => \$show_help,
) or pod2usage();

pod2usage() if $show_help;

$action = shift || pod2usage("Please specify an <action>");
pod2usage() if $action eq 'help';
pod2usage("Invalid <action> '$action'") unless grep { $_ eq $action } @valid_actions;

# list/ls/print operations are read-only
# add/edit/delete operations are read-write

my $master_password = get_master_password();

# Always read the secret data into memory.
my $secrets = read_secrets_from_file( $secrets_file, $master_password );

if ( $action eq 'list' || $action eq 'ls' ) {
    foreach my $canonical_name ( sort keys %{$secrets} ) {
        print "$secrets->{$canonical_name}->{name} :- $secrets->{$canonical_name}->{description}\n";
    }
}
elsif ( $action eq 'add' ) {
    if ( my $new_secret = get_new_secret() ) {
        if ( $secrets->{ $new_secret->{canonical_name} } ) {
            print "ERROR: $new_secret->{name} already exists. Exiting without saving...\n";
            exit 10;
        }
        $secrets->{ $new_secret->{canonical_name} } = $new_secret;
        write_secrets_to_file( $secrets, $secrets_file, $master_password );
    }
    else {
        print "ERROR: No new secret was added\n";
        exit 20;
    }
}
elsif ( grep { $_ eq $action } ( qw( print edit delete ) ) ) {
    my $secret_name = get_secret_name($action);

    if ( my $chosen_secret = get_secret_by_name( $secret_name, $secrets ) ) {
        if ( $action eq 'print' ) {
            print_secret($chosen_secret);
        }
        elsif ( $action eq 'delete' ) {
            if ( ask_user_input( "Please confirm deletion by typing 'DELETE $secret_name': " ) eq "DELETE $secret_name" ) {
                delete $secrets->{ $chosen_secret->{canonical_name} }; 
                write_secrets_to_file( $secrets, $secrets_file, $master_password );
                print "'$secret_name' deleted\n";
            }
            else {
                print "No secret was deleted\n";
            }
        }
        elsif ( $action eq 'edit' ) {
            print "TODO: Write edit code\n";
        }
    }
    else {
        print "ERROR: Unable to find a secret named '$secret_name'. Exiting...\n";
        exit 30;
    }
}

exit;

=head1 SUBROUTINES

=cut

=head2 get_master_password( )

Prompt the user for the password to decrypt the secrets file. This is done in
'noecho' mode, so the password doesn't appear on the screen.

Expects:
    None.

Returns:
    String containing the password to decrypt the secrets file.

=cut

sub get_master_password {

    my $master_password = ask_user_input( "Enter master password: ", 'noecho' );

    return $master_password;
}

=head2 print_secret( $secret )

Expects:
    A hashref containing the secret data.

Returns:
    None.

=cut

sub print_secret {
    my $secret = shift;

    print Dumper($secret);
}

=head2 get_secret_by_name( $secret_name, $secrets )

Expects:
    The full name of a secret.
    The set of all secrets.

Returns:
    The secret matching the canonical version of $secret_name if it exists.
    Else undef

=cut

sub get_secret_by_name {
    my $secret_name = shift;
    my $secrets     = shift;

    my $canonical_name = get_canonical_name($secret_name);

    return $secrets->{$canonical_name};
}

=head2 get_secret_name( )

Expects:
    A string representing the action the user is planning.

Returns:
    The name of a secret to operate on.

=cut

sub get_secret_name {
    my $action = shift;

    my $secret_name = ask_user_input("Which secret do you wish to $action? ");

    return $secret_name;
}

=head2 get_new_secret( )

Prompt the user for the required and optional data which make up a secret.

Expects:
    None.

Returns:
    Valid secret hash or undef.

=cut

sub get_new_secret {

    # Keys:
    #   name - required, shown in list mode.
    #   canonical_name - derived, used for deduplication.
    #   description - required, shown in list mode.
    #   username - required, shown only in print mode.
    #   password - required (asked twice for validation), shown only in print mode.
    #   url - optional, shown only in print mode.
    #   metadata = optional, shown only in print mode.

    my $new_secret;

    $new_secret->{name} = ask_user_input("Please enter the Name of the secret (min 4 chars): ");
    if ( length $new_secret->{name} < 4 ) {
        print "ERROR: Name must be at least 4 chars\n";
        return undef;
    }
    $new_secret->{canonical_name} = get_canonical_name( $new_secret->{name} );

    $new_secret->{description}
        = ask_user_input(
        "Please enter a short, one-line description for the secret. This will be shown in list view: "
        );

    $new_secret->{username}
        = ask_user_input("Please enter the username/login name/email address: ");

    $new_secret->{password} = ask_user_input( "Please enter the password: ", 'noecho' );
    my $confirmed_password = ask_user_input( "Please confirm the password: ", 'noecho' );

    if ( $new_secret->{password} ne $confirmed_password ) {
        print "ERROR: passwords don't match\n";
        return undef;
    }

    $new_secret->{url} = ask_user_input("Please enter an optional URL for this secret: ");

    print
        "Please enter some freeform text metadata about this secret. Enter a '.' on a line by itself to end.\n";
    while (1) {
        my $line = ask_user_input();
        last if $line eq '.';
        $new_secret->{metadata} .= "$line\n";
    }
    chomp $new_secret->{metadata};

    return $new_secret;
}

=head2 get_canonical_name($name)

Expects:
    Name of a secret.

Returns:
    Lowercased, whitespace-free version of name.

=cut

sub get_canonical_name {
    my $name = shift;

    my $canonical_name = lc $name;
    chomp $canonical_name;
    $canonical_name =~ s{\s+}{_}gxms;

    return $canonical_name;
}

=head2 write_secrets_to_file( $secrets, $secrets_file, $password )

Write the secrets data structure to the secrets file. The data is serialised
then encrypted, then written to disk.

NOTE: This will clobber any existing data in the file, so if you attempt to
write to the file from more then one process simultaneously, the last writer
will win.

TODO: Look at file locking code.

Expects:
    Secrets hash ref.
    Filename to write secrets to.
    Password to encrypt the files contents.

Returns:
    None.

=cut

sub write_secrets_to_file {
    my $secrets      = shift;
    my $secrets_file = shift;
    my $password     = shift;

    open my $file_handle, '>', $secrets_file
        or die "Unable to open secrets file '$secrets_file' for writing - $!";

    my $frozen = Storable::nfreeze($secrets);

    # TODO: Encrypt the frozen data.

    print $file_handle $frozen;

    close $file_handle or die "Unable to close secrets file '$secrets_file' after writing - $!";
}

=head2 read_secrets_from_file( $secrets_file, $password )

Expects:
    Filename to read secrets from.
    Password to decrypt the files contents.

Returns:
    If everything works (file exists, contains data, password works), then an
    hash ref of secrets.
    Else undef.

=cut

sub read_secrets_from_file {
    my $secrets_file = shift;
    my $password     = shift;

    # Case 1: Non-existant file. This is expected for a first run, or when a
    # new secrets filename is passed in.
    return undef unless -f $secrets_file;

    # Case 2: Existing file
    my $frozen = File::Slurp::read_file($secrets_file);
    return undef unless $frozen;

    # TODO: Decryption
    my $secrets = Storable::thaw($frozen);
    return $secrets;

}

=head2 ask_user_input( $prompt ) 

Expects:
    A textual prompt to print. Can be blank.
    A mode of normal|noecho when reading the input.

Returns:
    A chomped string from STDIN

=cut

sub ask_user_input {
    my $prompt = shift || '';
    my $mode   = shift || 'normal';

    print $prompt;
    Term::ReadKey::ReadMode($mode);
    my $input = Term::ReadKey::ReadLine(0);
    Term::ReadKey::ReadMode('normal');
    print "\n" if $mode eq 'noecho';
    chomp $input;

    return $input;
}
__END__
