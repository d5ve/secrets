#!/usr/bin/perl

use strict;
use warnings;

=head1 NAME

B<secrets> - Simple secure storage for logins and passwords.

=head1 VERSION

1.0 - Battle-hardened

=head1 SYNOPSIS

B<secrets> is a simple secure store for logins and passwords.

    Usage: secrets [options] 

    Options:

        --file=FILE     - Optional file containing secrets.
                          Defaults to ~/.secrets
        --help|?        - Print the help docs. Default behaviour.
        --man           - Print the full POD manual.

=head1 DESCRIPTION

B<secrets> is a simple commandline password keeper, written in perl, which
maintains an encrypted file containing a list of secrets. A secret is a set of
standard data like username, password, URL, plus a block of unstructured
notes. This allows you to also store things like memorable dates or places,
favourite sports teams, mother's maiden names for each place you need a login.
Being able to make all this data up for each login, and remember it, means that
it's less likely that someone could masquerade as you.

B<secrets> currenty uses Blowfish, via Crypt::CBC to encrypt the secrets file.

Each secret contains the following fields.

=over 4

=item * Name - This is a required field, and holds the main identifier for this
secret. Examples might be "Online Bank", or "SSL certificate password". This
field is shown in C<list> mode.

=item * Canonical name - This is derived from the Name field, and is currently
just a lowercased version. This is used as a hash key to prevent accidental
duplication due to case issues.

=item * Description - This is an optional short description of the secret. It is
shown in C<list> mode.

=item * Username - This is an optional field used to hold a username, login ID,
email address etc. 

=item * Password - This is an optional field used to hold a password. The user
enters this data twice to confirm that they have typed it correctly, and no
output is shown on the screen.

=item * Url - An optional field which can hold the URL of the service or login
page etc. No checking is done to make sure that the data in this field is
actually a URL.

=item * Notes - An optional multi-line free-text field. This can be used for
any arbitrary other information required about the secret. For example, an
online banking login may ask you for answers to questions such as mother's
maiden name, or memorable dates. It's more secure if you don't use real values
for these, and instead just make the answers up anew for each login.

=back

=cut

use Crypt::CBC;
use Data::Dumper;
$Data::Dumper::Sortkeys = 1;
use File::Slurp ();
use File::Spec  ();
use Getopt::Long qw( GetOptions );
use Pod::Usage qw( pod2usage );
use Storable      ();
use Term::ReadKey ();

our $VERSION = '1.000';
$VERSION = eval $VERSION;

my $secrets_file = 'temp_secrets';
my $show_help;
my $show_man;
my @valid_actions = qw( list ls add edit delete print );
my @fields        = qw( Name Description Username Password URL Notes );

my $action;

GetOptions(
    'file=s' => \$secrets_file,
    'help|?' => \$show_help,
    'manual' => \$show_man,
) or pod2usage();

pod2usage() if $show_help;
pod2usage( -verbose => 2 ) if $show_man;

if ( !-f $secrets_file ) {
    print "Unable to locate secrets file '$secrets_file'\n";
    my $prompt = "Would you like to create a new secrets file '$secrets_file'? <yes/no> ";
    while (1) {
        ( my $input = lc get_user_input($prompt) ) =~ s{ \s+ \z }{}xms;
        last if $input eq 'yes';
        if ( $input eq 'no' ) {
            print "Exiting...\n";
            exit;
        }
    }
}

my $master_password = get_master_password();

# Always read the secret data into memory.
my $secrets = read_secrets_from_file( $secrets_file, $master_password );

# list/ls/print operations are read-only
# add/edit/delete operations are read-write


exit;

=head1 SUBROUTINES

=cut

=head2 get_master_password( )

Prompt the user for the password to decrypt the secrets file. This is done in
'noecho' mode, so the password doesn't appear on the screen.

Expects:
    None.

Returns:
    String containing the password to decrypt the secrets file.

=cut

sub get_master_password {

    my $master_password = get_user_input( "Please enter master password: ", 'noecho' );

    return $master_password;
}

=head2 print_secret( $secret, $fields )

Prints any set fields of the secret to STDOUT.

Expects:
    A hashref containing the secret data.
    An array ref containing the fields to print.

Returns:
    None.

=cut

sub print_secret {
    my $secret = shift;
    my $fields = shift;

    print "\n$secret->{name}\n", "=" x length( $secret->{name} ), "\n";
    foreach my $field ( @{$fields} ) {
        $secret->{ lc $field } && print "$field: $secret->{lc $field}\n";
    }
    print "\n";
}

=head2 get_secret_by_name( $secret_name, $secrets )

Expects:
    The full name of a secret.
    The set of all secrets.

Returns:
    The secret matching the canonical version of $secret_name if it exists.
    Else undef

=cut

sub get_secret_by_name {
    my $secret_name = shift;
    my $secrets     = shift;

    my $canonical_name = get_canonical_name($secret_name);

    return $secrets->{$canonical_name};
}

=head2 get_secret_name( )

Expects:
    A string representing the action the user is planning.

Returns:
    The name of a secret to operate on.

=cut

sub get_secret_name {
    my $action = shift;

    my $secret_name = get_user_input("Which secret do you wish to $action? ");

    return $secret_name;
}

=head2 get_secret_fields( )

Prompt the user for the required and optional data which make up a secret.

The user will be prompted for the password twice to confirm that they have
typed it correctly, and no output is shown on the screen. The script dies if
the passwords entered are different.

The notes field is a multi-line one, and is ended by a '.' on a line by itself.

This sub is pretty ugly, as it's trying to do ugly things.

Expects:
    An array ref of field names.
    An optional secreti.

Returns:
    Valid secret hash or undef.

=cut

sub get_secret_fields {
    my $fields = shift;
    my $secret = shift || {};

    foreach my $field ( @{$fields} ) {

        # TODO: Look at embedding the mode and multiline stuff
        # into the $fields list itself.
        my $mode      = $field eq 'Password' ? 'noecho' : 'normal';
        my $multiline = $field eq 'Notes'    ? 1        : 0;
        my $confirm   = $field eq 'Password' ? 1        : 0;

        my $new_value;
        my $confirm_value;
        my $old_value = $secret->{ lc $field };

        if ( defined $old_value ) {

            # Show the previous value, and reuse it if the user just hits enter.
            my $old_value = $field eq 'Password' ? '********' : $secret->{ lc $field };
            if ($multiline) {
                $new_value = get_multiline_user_input( "$field: [\n$old_value\n]", $mode );
                $confirm_value = get_multiline_user_input( "Confirm $field: ", $mode ) if $confirm;
            }
            else {
                $new_value = get_user_input( "$field [$old_value]: ", $mode );
                $confirm_value = get_user_input( "Confirm $field ", $mode ) if $confirm;
            }

        }
        else {

            # No previous value, so just prompt for new value.
            if ($multiline) {
                $new_value = get_multiline_user_input( "$field: ", $mode );
                $confirm_value = get_multiline_user_input( "Confirm $field: ", $mode ) if $confirm;
            }
            else {
                $new_value = get_user_input( "$field: ", $mode );
                $confirm_value = get_user_input( "Confirm $field: ", $mode ) if $confirm;
            }
        }

        # We want to ensure that if a confirmation value was given, that it matches
        # the other value.
        if ( $confirm && defined $new_value && $new_value ne $confirm_value ) {
            die "ERROR: $field values don't match. Exiting without making any changes...\n";
        }

        $secret->{ lc $field } = defined $new_value && length $new_value ? $new_value : $old_value;
    }
    $secret->{canonical_name} = get_canonical_name( $secret->{name} );

    return $secret;
}

=head2 get_canonical_name($name)

Expects:
    Name of a secret.

Returns:
    Lowercased, whitespace-free version of name.

=cut

sub get_canonical_name {
    my $name = shift;

    my $canonical_name = lc $name;
    chomp $canonical_name;
    $canonical_name =~ s{\s+}{_}gxms;

    return $canonical_name;
}

=head2 write_secrets_to_file( $secrets, $secrets_file, $password )

Write the secrets data structure to the secrets file. The data is serialised
then encrypted, then written to disk.

NOTE: This will clobber any existing data in the file, so if you attempt to
write to the file from more then one process simultaneously, the last writer
will win.

TODO: Look at file locking code.

Expects:
    Secrets hash ref.
    Filename to write secrets to.
    Password to encrypt the files contents.

Returns:
    None.

=cut

sub write_secrets_to_file {
    my $secrets      = shift;
    my $secrets_file = shift;
    my $password     = shift;

    my $frozen = Storable::nfreeze($secrets);

    my $cipher = Crypt::CBC->new(
        -key    => $password,
        -cipher => 'Blowfish'
    );

    my $ciphertext = $cipher->encrypt($frozen);

    File::Slurp::write_file( $secrets_file, { binmode => ':raw' }, $ciphertext );
}

=head2 read_secrets_from_file( $secrets_file, $password )

Expects:
    Filename to read secrets from.
    Password to decrypt the files contents.

Returns:
    If everything works (file exists, contains data, password works), then an
    hash ref of secrets.
    Else undef.

=cut

sub read_secrets_from_file {
    my $secrets_file = shift;
    my $password     = shift;

    # Non-existant file. This is an anomoly, as we should have already checked
    # for existence before the mainloop starts.
    die "ERROR: Unable to find secrets file '$secrets_file'. Exiting...\n" unless -f $secrets_file;

    # Read
    my $ciphertext = File::Slurp::read_file($secrets_file);
    return undef unless length $ciphertext;

    # Decrypt
    my $cipher = Crypt::CBC->new(
        -key    => $password,
        -cipher => 'Blowfish'
    );
    my $frozen = $cipher->decrypt($ciphertext);

    # Deserialise
    my $secrets;
    eval { $secrets = Storable::thaw($frozen); };
    if ($@) {

        # We're using nfreeze, so we shouldn't ever run into issues thawing.
        # So, if there is an issue, we are going to assume that it's related
        # to having the wrong password, and thus garbage data.
        # I can't see anything in Crypt::CBC which can tell us whether decryption
        # actually failed.

        die "ERROR: Unable to decrypt secrets file. Exiting...\n";
    }

    return $secrets;

}

=head2 get_user_input( $prompt, [$mode] ) 

Prompt the user for input, optionally hide what they're typing, and chomp any
string entered.

Expects:
    A textual prompt to print. Can be blank.
    A mode of normal|noecho when reading the input.

Returns:
    A chomped string from STDIN

=cut

sub get_user_input {
    my $prompt = shift || '';
    my $mode   = shift || 'normal';

    print $prompt;
    Term::ReadKey::ReadMode($mode);
    my $input = Term::ReadKey::ReadLine(0);
    Term::ReadKey::ReadMode('normal');
    print "\n" if $mode eq 'noecho';

    chomp $input;
    return $input;
}

=head2 get_multiline_user_input( $prompt, [$mode] ) 

Prompt the user for multiple lines ofinput, optionally hide what they're
typing, and chomp any string entered.

This is a loop around get_user_input().

Expects:
    A textual prompt to print. Can be blank.
    A mode of normal|noecho when reading the input.

Returns:
    A chomped string from STDIN

=cut

sub get_multiline_user_input {
    my $prompt = shift || '';
    my $mode   = shift || 'normal';

    print "$prompt\n(Enter a '.' on a line by itself to end)\n";
    my $input;
    while (1) {
        my $line = get_user_input( '', $mode );
        last if $line eq '.';
        $input .= "$line\n";
    }
    chomp $input if defined $input;
    return $input;
}

__END__

=head1 CAVEATS

The author of this script isn't a security professional, and this script hasn't
been audited for flaws or bugs - which there almost certainly are.

This script does no file locking, so running it in parallel may result in data
loss, where the last writer wins.

If you run it with blank or missing secrets file, it will create a new one for
you. However it will only ask for the master password once!

=head1 TODO

=over 4

=item * Provide a shorthand for editing the multi-line notes field when you
don't want to change anything. Currently you need to copy-n-paste the whole
thing.

=item * Add messages when a new password file is about to be created. Plus
prompt for the new master password twice.

=item * Allow you to change the master password - will require reading the file
into memory, then prompting for new password twice, then writing it back out.

=item * Serialise using something different to Storable, to allow non-perl
scripts to also use the secrets file. JSON seems a likely contender, at the
expense of needing extra CPAN installs.

=item * Look at file locking to prevent data loss.

=item * Allow tweaking of encryption parameters.

=item * Enforce useful-length master passwords.

=item * Look at what perl can do to make it more difficult to recover passwords
from RAM.

=item * Look at ways to try and prevent the OS swapping the decrypted data to
disk.

=item * Look at pattern matching canonical names, rather than requiring exact
matches.

=item * Look at adding a group level of hierarchy, for example, being able to
group all your banking logins together somehow.

=back

=head1 SEE ALSO

=over 4

=item * B<pwsafe> from http://nsd.dyndns.org/pwsafe/

This is a commandline frontend to the B<Counterpane Password Safe> data files.

I used B<pwsafe> for a year or so, but was frustrated that it didn't allow me
to store much data about a particular login. B<secrets> shares some of the
basic process flow with B<pwsafe>, but adds a general notes storage. B<pwsafe>
has far more features than B<secrets>.

=back

=head1 AUTHOR

Dave Webb L<secrets.github@d5ve.com>

=head1 LICENSE

B<secrets> is free software. It comes without any warranty, to the extent permitted
by applicable law.

B<secrets> is released under the I<WTFPL Version 2.0> license - L<http://sam.zoy.org/wtfpl/COPYING>

0. You just DO WHAT THE FUCK YOU WANT TO.

=cut
