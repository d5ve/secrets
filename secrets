#!/usr/bin/perl

use strict;
use warnings;

=head1 WORK IN PROGRESS

This script currently does nothing apart from basic param validation and
reading/writing to secrets file. No encryption is done.

=cut

use Getopt::Long qw( GetOptions );
use Pod::Usage qw( pod2usage );
use File::Spec    ();
use Term::ReadKey ();
use Storable      ();
use Data::Dumper; $Data::Dumper::Sortkeys = 1;

our $VERSION = '0.002';
$VERSION = eval $VERSION;

my $secrets_file = File::Spec->catfile( $ENV{HOME}, '.secrets' );
my $show_help;
my @valid_actions = qw( list ls add edit delete print );

my $action;

GetOptions(
    'file=s' => \$secrets_file,
    'help|?' => \$show_help,
) or pod2usage();

$action = shift || pod2usage("Please specify an <action>");
pod2usage("Invalid <action> '$action'") unless grep { $_ eq $action } @valid_actions;

# list/ls/print operations are read-only
# add/edit/delete operations are read-write

my $master_password = get_master_password();

# Always read the secret data into memory.
my $secrets = read_secrets_from_file( $secrets_file, $master_password );
print Dumper($secrets);

if ( $action eq 'list' || $action eq 'ls' ) {
    foreach my $canonical_name ( sort keys %{ $secrets } ) {
        print "$secrets->{$canonical_name}->{name} :- $secrets->{$canonical_name}->{description}\n";
    }
}
elsif ( $action eq 'add' ) {
    if ( my $new_secret = get_new_secret() ) {
        if ( $secrets->{ $new_secret->{name} } ) {
            print "ERROR: $new_secret->{name} already exists. Exiting without saving...\n";
            exit 10;
        }
        $secrets->{ $new_secret->{name} } = $new_secret->{name};
        print Dumper('$secrets' => $secrets);
        write_secrets_to_file( $secrets, $secrets_file, $master_password );
    }
    else {
        print "ERROR: No new secret was added\n";
        exit 20;
    }
}

exit;

=head1 SUBROUTINES

=cut

=head2 get_master_password( )

Prompt the user for the password to decrypt the secrets file. This is done in
'noecho' mode, so the password doesn't appear on the screen.

Expects:
    None.

Returns:
    String containing the password to decrypt the secrets file.

=cut

sub get_master_password {

    print "Enter master password: ";
    Term::ReadKey::ReadMode('noecho');
    my $master_password = Term::ReadKey::ReadLine(0);
    Term::ReadKey::ReadMode('normal');
    print "\n";

    return $master_password;
}

=head2 get_new_secret( )

Prompt the user for the required and optional data which make up a secret.

Expects:
    None.

Returns:
    Valid secret hash or undef.

=cut

sub get_new_secret {

    # Keys:
    #   name - required, shown in list mode.
    #   canonical_name - derived, used for deduplication.
    #   description - required, shown in list mode.
    #   username - required, shown only in print mode.
    #   password - required (asked twice for validation), shown only in print mode.
    #   url - optional, shown only in print mode.
    #   metadata = optional, shown only in print mode.

    Term::ReadKey::ReadMode('normal');
    print "Please enter the Name of the secret (min 4 chars): ";
    my $name = Term::ReadKey::ReadLine(0);
    if ( length $name < 4 ) {
        print "ERROR: Name must be at least 4 chars\n";
        return undef;
    }
    my $canonical_name = get_canonical_name($name);
    
    print "Please enter a short, one-line description for the secret. This will be shown in list view: ";
    my $description = Term::ReadKey::ReadLine(0);

    print "Please enter the username/login name/email address: ";
    my $username = Term::ReadKey::ReadLine(0);

    print "Please enter the password: ";
    Term::ReadKey::ReadMode('noecho');
    my $password = Term::ReadKey::ReadLine(0);
    Term::ReadKey::ReadMode('normal');
    print "\nPlease confirm the password: ";
    Term::ReadKey::ReadMode('noecho');
    my $confirmed_password = Term::ReadKey::ReadLine(0);
    Term::ReadKey::ReadMode('normal');
    print "\n";

    if ( $password ne $confirmed_password ) {
        print "ERROR: passwords don't match\n";
        return undef;
    }

    print "Please enter an optional URL for this secret: ";
    my $url = Term::ReadKey::ReadLine(0);

    print "Please enter some freeform text metadata about this secret. Enter a '.' on a line by itself to end.\n";
    my $metadata;
    while ( 1 ) {
        my $line = Term::ReadKey::ReadLine(0);
        chomp $line;
        last if $line eq '.';
        $metadata .= "\n$line"; 
    }

    return {
        name => $name,
        canonical_name => $canonical_name,
        description => $description,
        username => $username,
        password => $password,
        url => $url,
        metadata => $metadata,
    };
}

=head2 get_canonical_name($name)

Expects:
    Name of a secret.

Returns:
    Lowercased, whitespace-free version of name.

=cut

sub get_canonical_name {
    my $name = shift;

    my $canonical_name = lc $name;
    $canonical_name =~ s{\s+}{_}gxms;

    return $canonical_name;
}

=head2 write_secrets_to_file( $secrets, $secrets_file, $password )

Write the secrets data structure to the secrets file. The data is serialised
then encrypted, then written to disk.

NOTE: This will clobber any existing data in the file, so if you attempt to
write to the file from more then one process simultaneously, the last writer
will win.

TODO: Look at file locking code.

Expects:
    Secrets hash ref.
    Filename to write secrets to.
    Password to encrypt the files contents.

Returns:
    None.

=cut

sub write_secrets_to_file {
    my $secrets      = shift;
    my $secrets_file = shift;
    my $password     = shift;

    open my $file_handle, '>', $secrets_file
        or die "Unable to open secrets file '$secrets_file' for writing - $!";

    my $frozen = Storable::nfreeze($secrets);

    # TODO: Encrypt the frozen data.

    print $file_handle $frozen;

    close $file_handle or die "Unable to close secrets file '$secrets_file' after writing - $!";
}

=head2 read_secrets_from_file( $secrets_file, $password )

Expects:
    Filename to read secrets from.
    Password to decrypt the files contents.

Returns:
    If everything works (file exists, contains data, password works), then an
    hash ref of secrets.
    Else undef.

=cut

sub read_secrets_from_file {
    my $secrets_file = shift;
    my $password     = shift;

    # Case 1: Non-existant file. This is expected for a first run, or when a
    # new secrets filename is passed in.
    return undef unless -f $secrets_file;

    # Case 2: Existing file
    #   Open
    open my $file_handle, '<', $secrets_file
        or die "Unable to open secrets file '$secrets_file' for reading - $!";

    #   Read
    my $frozen = do { local $\ = <$file_handle> };
    print "LEN: " . length($frozen) . "\n";
    close $file_handle or die "Unable to close secrets file '$secrets_file' after reading - $!";
    return undef unless length $frozen;

    # TODO: Decryption
    #   Deserialise
    my $secrets = Storable::thaw $frozen;
    print Dumper($secrets);
    return $secrets;

}

__END__
