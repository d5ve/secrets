#!/usr/bin/perl

use strict;
use warnings;

=head1 WORK IN PROGRESS

This script currently does nothing apart from basic param validation and
reading/writing to secrets file. No encryption is done.

=cut

use Getopt::Long qw( GetOptions );
use Pod::Usage qw( pod2usage );
use File::Spec    ();
use Term::ReadKey ();
use Storable      ();

our $VERSION = '0.002';
$VERSION = eval $VERSION;

my $secrets_file = File::Spec->catfile( $ENV{HOME}, '.secrets' );
my $show_help;
my @valid_actions = qw( list ls add edit delete print );

my $action;

GetOptions(
    'file=s' => \$secrets_file,
    'help|?' => \$show_help,
) or pod2usage();

$action = shift || pod2usage("Please specify an <action>");
pod2usage("Invalid <action> '$action'") unless grep { $_ eq $action } @valid_actions;

# list/ls/print operations are read-only
# add/edit/delete operations are read-write

my $master_password = get_master_password();

# Always read the secret data into memory.
my $secrets = read_secrets_from_file( $secrets_file, $master_password );

exit;

=head1 SUBROUTINES

=head2 get_master_password( )

Prompt the user for the password to decrypt the secrets file. This is done in
'noecho' mode, so the password doesn't appear on the screen.

Expects:
    None.

Returns:
    String containing the password to decrypt the secrets file.

=cut

sub get_master_password {

    print "Enter master password: ";
    Term::ReadKey::ReadMode('noecho');
    $master_password = Term::ReadKey::ReadLine(0);
    Term::ReadKey::ReadMode('normal');
    print "\n";

    return $master_password;
}

=head2 write_secrets_to_file( $secrets, $secret_file, $password )

Write the secrets data structure to the secrets file. The data is serialised
then encrypted, then written to disk.

NOTE: This will clobber any existing data in the file, so if you attempt to
write to the file from more then one process simultaneously, the last writer
will win.

TODO: Look at file locking code.

Expects:
    Secrets array ref.
    Filename to write secrets to.
    Password to encrypt the files contents.

Returns:
    None.

=cut

sub write_secrets_to_file {
    my $secrets      = shift;
    my $secrets_file = shift;
    my $password     = shift;

    open my $file_handle, '>', $secrets_file
        or die "Unable to open secrets file '$secrets_file' for writing - $!";

    my $frozen = Storable::nfreeze($secrets);

    # TODO: Encrypt the frozen data.

    print $file_handle $frozen;

    close $file_handle or die "Unable to close secrets file '$secrets_file' after writing - $!";
}

=head2 read_secrets_from_file( $secret_file, $password )

Expects:
    Filename to read secrets from.
    Password to decrypt the files contents.

Returns:
    If everything works (file exists, contains data, password works), then an
    array ref containing a list of secrets hashes.
    Else undef.

=cut

sub read_secrets_from_file {
    my $secrets_file = shift;
    my $password     = shift;

    # Case 1: Non-existant file. This is expected for a first run, or when a
    # new secrets filename is passed in.
    return undef unless -f $secrets_file;

    # Case 2: Existing file
    #   Open
    open my $file_handle, '<', $secrets_file
        or die "Unable to open secrets file '$secrets_file' for reading - $!";

    #   Read
    my $frozen = do { local $\ = <$file_handle> };
    close $file_handle or die "Unable to close secrets file '$secrets_file' after reading - $!";
    return undef unless length $frozen;

    # TODO: Decryption
    #   Deserialise
    my $secrets = Storable::thaw $frozen;

    return $secrets;

}

__END__
