#!/usr/bin/perl

use strict;
use warnings;

=head1 NAME

B<secrets> - Simple secure storage for logins and passwords.

=head1 VERSION

0.91 - Just good enough for daily use.

=head1 SYNOPSIS

B<secrets> is a simple secure store for logins and passwords.

    Usage: secrets [options] <action>

    Options:

        --file=FILE     - Optional file containing secrets.
                          Defaults to ~/.secrets
        --help|?        - Print the help docs. Default behaviour.
        --man           - Print the full POD manual.

    Actions:

        list|ls         - List the available secret names.
        print           - Print the password and other notes about a particular secret.
        add             - Add a new secret. This prompts for username/password etc.
        edit            - Edit an existing secret.
        delete          - Delete an existing secret.
        help            - Print help docs. Default action.

    All operations prompt for the master password before doing anything.

    Any operations which need the user to specify the name of a secret will
    prompt for it interactively, rather than passing it directly as an argument.
    This prevents the names of secrets appearing in the user's shell history.

    Examples:
    
        # List the names of the stored secrets.
        $ secrets list
        $ secrets ls

        # Print to STDOUT the username/password and other notes about
        # a secret.
        # You will be prompted for the name of the secret to print.
        $ secrets print 

        # Add/Edit/Delete a secret.
        # You will be prompted for the name of the secret.
        $ secrets add
        $ secrets edit
        $ secrets delete 

=head1 DESCRIPTION

B<secrets> is a simple commandline password keeper, written in perl, which
maintains an encrypted file containing a list of secrets. A secret is a set of
standard data like username, password, URL, plus a block of unstructured
notes. This allows you to also store things like memorable dates or places,
favourite sports teams, mother's maiden names for each place you need a login.
Being able to make all this data up for each login, and remember it, means that
it's less likely that someone could masquerade as you.

B<secrets> currenty uses Blowfish, via Crypt::CBC to encrypt the secrets file.

Each secret contains the following fields.

=over 4

=item * Name - This is a required field, and holds the main identifier for this
secret. Examples might be "Online Bank", or "SSL certificate password". This
field is shown in C<list> mode.

=item * Canonical name - This is derived from the Name field, and is currently
just a lowercased version. This is used as a hash key to prevent accidental
duplication due to case issues.

=item * Description - This is an optional short description of the secret. It is
shown in C<list> mode.

=item * Username - This is an optional field used to hold a username, login ID,
email address etc. 

=item * Password - This is an optional field used to hold a password. The user
enters this data twice to confirm that they have typed it correctly, and no
output is shown on the screen.

=item * Url - An optional field which can hold the URL of the service or login
page etc. No checking is done to make sure that the data in this field is
actually a URL.

=item * Notes - An optional multi-line free-text field. This can be used for
any arbitrary other information required about the secret. For example, an
online banking login may ask you for answers to questions such as mother's
maiden name, or memorable dates. It's more secure if you don't use real values
for these, and instead just make the answers up anew for each login.

=back

=cut

use Crypt::CBC;
use Data::Dumper;
$Data::Dumper::Sortkeys = 1;
use File::Slurp ();
use File::Spec  ();
use Getopt::Long qw( GetOptions );
use Pod::Usage qw( pod2usage );
use Storable      ();
use Term::ReadKey ();

our $VERSION = '0.910';
$VERSION = eval $VERSION;

my $secrets_file = File::Spec->catfile( $ENV{HOME}, '.secrets' );
my $show_help;
my $show_man;
my @valid_actions = qw( list ls add edit delete print );
my @fields        = qw( Name Description Username Password URL Notes );

my $action;

GetOptions(
    'file=s' => \$secrets_file,
    'help|?' => \$show_help,
    'manual' => \$show_man,
) or pod2usage();

pod2usage() if $show_help;
pod2usage( -verbose => 2 ) if $show_man;

$action = shift || pod2usage("Please specify an <action>");
pod2usage() if $action eq 'help';
pod2usage("Invalid <action> '$action'") unless grep { $_ eq $action } @valid_actions;

# list/ls/print operations are read-only
# add/edit/delete operations are read-write

my $master_password = get_master_password();

# Always read the secret data into memory.
my $secrets = read_secrets_from_file( $secrets_file, $master_password );

if ( $action eq 'list' || $action eq 'ls' ) {

    # Ugh, two passes to make it pretty print
    my $max_name_len = 0;

    foreach my $canonical_name ( sort keys %{$secrets} ) {
        $max_name_len = length $secrets->{$canonical_name}->{name}
            if length $secrets->{$canonical_name}->{name} > $max_name_len;
    }
    foreach my $canonical_name ( sort keys %{$secrets} ) {
        my $print_name = $secrets->{$canonical_name}->{name}
            . ' ' x ( $max_name_len - length $secrets->{$canonical_name}->{name} );
        print "$print_name :- $secrets->{$canonical_name}->{description}\n";
    }
}
elsif ( $action eq 'add' ) {
    if ( my $new_secret = get_secret_fields( \@fields ) ) {
        if ( $secrets->{ $new_secret->{canonical_name} } ) {
            print "ERROR: $new_secret->{name} already exists. Exiting without saving...\n";
            exit 10;
        }
        $secrets->{ $new_secret->{canonical_name} } = $new_secret;
        write_secrets_to_file( $secrets, $secrets_file, $master_password );
    }
    else {
        print "ERROR: No new secret was added\n";
        exit 20;
    }
}
elsif ( grep { $_ eq $action } (qw( print edit delete )) ) {
    my $secret_name = get_secret_name($action);

    if ( my $chosen_secret = get_secret_by_name( $secret_name, $secrets ) ) {
        if ( $action eq 'print' ) {
            print_secret( $chosen_secret, \@fields );
        }
        elsif ( $action eq 'delete' ) {
            if ( get_user_input("Please confirm deletion by typing 'DELETE $secret_name': ") eq
                "DELETE $secret_name" )
            {
                delete $secrets->{ $chosen_secret->{canonical_name} };
                write_secrets_to_file( $secrets, $secrets_file, $master_password );
                print "'$secret_name' deleted\n";
            }
            else {
                print "No secret was deleted\n";
            }
        }
        elsif ( $action eq 'edit' ) {
            my $edited_secret = get_secret_fields( \@fields, $chosen_secret );
            if ( $edited_secret->{canonical_name} ne $chosen_secret->{canonical_name} ) {

                # Handle potential renaming of the secret.
                delete $chosen_secret->{canonical_name};
            }
            $secrets->{ $edited_secret->{canonical_name} } = $edited_secret;
            write_secrets_to_file( $secrets, $secrets_file, $master_password );
        }
    }
    else {
        print "ERROR: Unable to find a secret named '$secret_name'. Exiting...\n";
        exit 30;
    }
}

exit;

=head1 SUBROUTINES

=cut

=head2 get_master_password( )

Prompt the user for the password to decrypt the secrets file. This is done in
'noecho' mode, so the password doesn't appear on the screen.

Expects:
    None.

Returns:
    String containing the password to decrypt the secrets file.

=cut

sub get_master_password {

    my $master_password = get_user_input( "Please enter master password: ", 'noecho' );

    return $master_password;
}

=head2 print_secret( $secret, $fields )

Prints any set fields of the secret to STDOUT.

Expects:
    A hashref containing the secret data.
    An array ref containing the fields to print.

Returns:
    None.

=cut

sub print_secret {
    my $secret = shift;
    my $fields = shift;

    print "\n$secret->{name}\n", "=" x length( $secret->{name} ), "\n";
    foreach my $field ( @{$fields} ) {
        $secret->{ lc $field } && print "$field: $secret->{lc $field}\n";
    }
    print "\n";
}

=head2 get_secret_by_name( $secret_name, $secrets )

Expects:
    The full name of a secret.
    The set of all secrets.

Returns:
    The secret matching the canonical version of $secret_name if it exists.
    Else undef

=cut

sub get_secret_by_name {
    my $secret_name = shift;
    my $secrets     = shift;

    my $canonical_name = get_canonical_name($secret_name);

    return $secrets->{$canonical_name};
}

=head2 get_secret_name( )

Expects:
    A string representing the action the user is planning.

Returns:
    The name of a secret to operate on.

=cut

sub get_secret_name {
    my $action = shift;

    my $secret_name = get_user_input("Which secret do you wish to $action? ");

    return $secret_name;
}

=head2 get_secret_fields( )

Prompt the user for the required and optional data which make up a secret.

The user will be prompted for the password twice to confirm that they have
typed it correctly, and no output is shown on the screen. The script dies if
the passwords entered are different.

The notes field is a multi-line one, and is ended by a '.' on a line by itself.

This sub is pretty ugly, as it's trying to do ugly things.

Expects:
    An array ref of field names.
    An optional secreti.

Returns:
    Valid secret hash or undef.

=cut

sub get_secret_fields {
    my $fields = shift;
    my $secret = shift || {};

    foreach my $field ( @{$fields} ) {

        # TODO: Look at embedding the mode and multiline stuff
        # into the $fields list itself.
        my $mode      = $field eq 'Password' ? 'noecho' : 'normal';
        my $multiline = $field eq 'Notes'    ? 1        : 0;
        my $confirm   = $field eq 'Password' ? 1        : 0;

        my $new_value;
        my $confirm_value;
        my $old_value = $secret->{ lc $field };

        if ( defined $old_value ) {

            # Show the previous value, and reuse it if the user just hits enter.
            my $old_value = $field eq 'Password' ? '********' : $secret->{ lc $field };
            if ($multiline) {
                $new_value = get_multiline_user_input( "$field: [\n$old_value\n]", $mode );
                $confirm_value = get_multiline_user_input( "Confirm $field: ", $mode ) if $confirm;
            }
            else {
                $new_value = get_user_input( "$field [$old_value]: ", $mode );
                $confirm_value = get_user_input( "Confirm $field ", $mode ) if $confirm;
            }

        }
        else {

            # No previous value, so just prompt for new value.
            if ($multiline) {
                $new_value = get_multiline_user_input( "$field: ", $mode );
                $confirm_value = get_multiline_user_input( "Confirm $field: ", $mode ) if $confirm;
            }
            else {
                $new_value = get_user_input( "$field: ", $mode );
                $confirm_value = get_user_input( "Confirm $field: ", $mode ) if $confirm;
            }
        }

        # We want to ensure that if a confirmation value was given, that it matches
        # the other value.
        if ( $confirm && defined $new_value && $new_value ne $confirm_value ) {
            die "ERROR: $field values don't match. Exiting without making any changes...\n";
        }

        $secret->{ lc $field } = defined $new_value && length $new_value ? $new_value : $old_value;
    }
    $secret->{canonical_name} = get_canonical_name( $secret->{name} );

    return $secret;
}

=head2 get_canonical_name($name)

Expects:
    Name of a secret.

Returns:
    Lowercased, whitespace-free version of name.

=cut

sub get_canonical_name {
    my $name = shift;

    my $canonical_name = lc $name;
    chomp $canonical_name;
    $canonical_name =~ s{\s+}{_}gxms;

    return $canonical_name;
}

=head2 write_secrets_to_file( $secrets, $secrets_file, $password )

Write the secrets data structure to the secrets file. The data is serialised
then encrypted, then written to disk.

NOTE: This will clobber any existing data in the file, so if you attempt to
write to the file from more then one process simultaneously, the last writer
will win.

TODO: Look at file locking code.

Expects:
    Secrets hash ref.
    Filename to write secrets to.
    Password to encrypt the files contents.

Returns:
    None.

=cut

sub write_secrets_to_file {
    my $secrets      = shift;
    my $secrets_file = shift;
    my $password     = shift;

    my $frozen = Storable::nfreeze($secrets);

    my $cipher = Crypt::CBC->new(
        -key    => $password,
        -cipher => 'Blowfish'
    );

    my $ciphertext = $cipher->encrypt($frozen);

    File::Slurp::write_file( $secrets_file, { binmode => ':raw' }, $ciphertext );
}

=head2 read_secrets_from_file( $secrets_file, $password )

Expects:
    Filename to read secrets from.
    Password to decrypt the files contents.

Returns:
    If everything works (file exists, contains data, password works), then an
    hash ref of secrets.
    Else undef.

=cut

sub read_secrets_from_file {
    my $secrets_file = shift;
    my $password     = shift;

    # Case 1: Non-existant file. This is expected for a first run, or when a
    # new secrets filename is passed in.
    return undef unless -f $secrets_file;

    # Case 2: Existing file
    #   - Read
    my $ciphertext = File::Slurp::read_file($secrets_file);
    return undef unless length $ciphertext;

    #   - Decrypt
    my $cipher = Crypt::CBC->new(
        -key    => $password,
        -cipher => 'Blowfish'
    );
    my $frozen = $cipher->decrypt($ciphertext);

    #   - Deserialise
    my $secrets;
    eval { $secrets = Storable::thaw($frozen); };
    if ($@) {

        # We're using nfreeze, so we shouldn't ever run into issues thawing.
        # So, if there is an issue, we are going to assume that it's related
        # to having the wrong password, and thus garbage data.
        # I can't see anything in Crypt::CBC which can tell us whether decryption
        # actually failed.

        die "ERROR: Unable to decrypt secrets file. Exiting...\n";
    }

    return $secrets;

}

=head2 get_user_input( $prompt, [$mode] ) 

Prompt the user for input, optionally hide what they're typing, and chomp any
string entered.

Expects:
    A textual prompt to print. Can be blank.
    A mode of normal|noecho when reading the input.

Returns:
    A chomped string from STDIN

=cut

sub get_user_input {
    my $prompt = shift || '';
    my $mode   = shift || 'normal';

    print $prompt;
    Term::ReadKey::ReadMode($mode);
    my $input = Term::ReadKey::ReadLine(0);
    Term::ReadKey::ReadMode('normal');
    print "\n" if $mode eq 'noecho';

    chomp $input;
    return $input;
}

=head2 get_multiline_user_input( $prompt, [$mode] ) 

Prompt the user for multiple lines ofinput, optionally hide what they're
typing, and chomp any string entered.

This is a loop around get_user_input().

Expects:
    A textual prompt to print. Can be blank.
    A mode of normal|noecho when reading the input.

Returns:
    A chomped string from STDIN

=cut

sub get_multiline_user_input {
    my $prompt = shift || '';
    my $mode   = shift || 'normal';

    print "$prompt\n(Enter a '.' on a line by itself to end)\n";
    my $input;
    while (1) {
        my $line = get_user_input( '', $mode );
        last if $line eq '.';
        $input .= "$line\n";
    }
    chomp $input if defined $input;
    return $input;
}

__END__

=head1 CAVEATS

The author of this script isn't a security professional, and this script hasn't
been audited for flaws or bugs - which there almost certainly are.

This script does no file locking, so running it in parallel may result in data
loss, where the last writer wins.

If you run it with blank or missing secrets file, it will create a new one for
you. However it will only ask for the master password once!

=head1 TODO

=over 4

=item * Add messages when a new password file is about to be created. Plus
prompt for the new master password twice.

=item * Allow you to change the master password - will require reading the file
into memory, then prompting for new password twice, then writing it back out.

=item * Serialise using something different to Storable, to allow non-perl
scripts to also use the secrets file. JSON seems a likely contender, at the
expense of needing extra CPAN installs.

=item * Look at file locking to prevent data loss.

=item * Allow tweaking of encryption parameters.

=item * Enforce useful-length master passwords.

=item * Look at what perl can do to make it more difficult to recover passwords
from RAM.

=item * Look at ways to try and prevent the OS swapping the decrypted data to
disk.

=item * Look at pattern matching canonical names, rather than requiring exact
matches.

=item * Look at adding a group level of hierarchy, for example, being able to
group all your banking logins together somehow.

=back

=head1 SEE ALSO

=over 4

=item * B<pwsafe> from http://nsd.dyndns.org/pwsafe/

This is a commandline frontend to the B<Counterpane Password Safe> data files.

I used B<pwsafe> for a year or so, but was frustrated that it didn't allow me
to store much data about a particular login. B<secrets> shares some of the
basic process flow with B<pwsafe>, but adds a general notes storage. B<pwsafe>
has far more features than B<secrets>.

=back

=head1 AUTHOR

Dave Webb L<secrets.github@d5ve.com>

=head1 LICENSE

B<secrets> is free software. It comes without any warranty, to the extent permitted
by applicable law.

B<secrets> is released under the I<WTFPL Version 2.0> license - L<http://sam.zoy.org/wtfpl/COPYING>

0. You just DO WHAT THE FUCK YOU WANT TO.

=cut
