#!/usr/bin/perl

use strict;
use warnings;

=head1 WORK IN PROGRESS

This script currently handles adding/deleting/listing/printing secrets, BUT NO
ENCRYPTION IS DONE YET.

TODO: Encryption of secrets file.
TODO: Edit functionality

=cut

use Data::Dumper;
$Data::Dumper::Sortkeys = 1;
use File::Slurp ();
use File::Spec  ();
use Getopt::Long qw( GetOptions );
use Pod::Usage qw( pod2usage );
use Storable      ();
use Term::ReadKey ();

our $VERSION = '0.006';
$VERSION = eval $VERSION;

my $secrets_file = File::Spec->catfile( $ENV{HOME}, '.secrets' );
my $show_help;
my @valid_actions = qw( list ls add edit delete print );
my @fields = qw( Description Username Password URL Metadata );

my $action;

GetOptions(
    'file=s' => \$secrets_file,
    'help|?' => \$show_help,
) or pod2usage();

pod2usage() if $show_help;

$action = shift || pod2usage("Please specify an <action>");
pod2usage() if $action eq 'help';
pod2usage("Invalid <action> '$action'") unless grep { $_ eq $action } @valid_actions;

# list/ls/print operations are read-only
# add/edit/delete operations are read-write

my $master_password = get_master_password();

# Always read the secret data into memory.
my $secrets = read_secrets_from_file( $secrets_file, $master_password );

if ( $action eq 'list' || $action eq 'ls' ) {
    foreach my $canonical_name ( sort keys %{$secrets} ) {
        print "$secrets->{$canonical_name}->{name} :- $secrets->{$canonical_name}->{description}\n";
    }
}
elsif ( $action eq 'add' ) {
    if ( my $new_secret = get_secret_fields(\@fields) ) {
        if ( $secrets->{ $new_secret->{canonical_name} } ) {
            print "ERROR: $new_secret->{name} already exists. Exiting without saving...\n";
            exit 10;
        }
        $secrets->{ $new_secret->{canonical_name} } = $new_secret;
        write_secrets_to_file( $secrets, $secrets_file, $master_password );
    }
    else {
        print "ERROR: No new secret was added\n";
        exit 20;
    }
}
elsif ( grep { $_ eq $action } ( qw( print edit delete ) ) ) {
    my $secret_name = get_secret_name($action);

    if ( my $chosen_secret = get_secret_by_name( $secret_name, $secrets ) ) {
        if ( $action eq 'print' ) {
            print_secret($chosen_secret, \@fields);
        }
        elsif ( $action eq 'delete' ) {
            if ( get_user_input( "Please confirm deletion by typing 'DELETE $secret_name': " ) eq "DELETE $secret_name" ) {
                delete $secrets->{ $chosen_secret->{canonical_name} }; 
                write_secrets_to_file( $secrets, $secrets_file, $master_password );
                print "'$secret_name' deleted\n";
            }
            else {
                print "No secret was deleted\n";
            }
        }
        elsif ( $action eq 'edit' ) {
            my $edited_secret = get_secret_fields(\@fields, $chosen_secret);
            if ( $edited_secret->{canonical_name} ne $chosen_secret->{canonical_name} ) {
                # Handle potential renaming of the secret.
                delete $chosen_secret->{canonical_name};
            }
            $secrets->{ $edited_secret->{canonical_name} } = $edited_secret;
            write_secrets_to_file( $secrets, $secrets_file, $master_password );
        }
    }
    else {
        print "ERROR: Unable to find a secret named '$secret_name'. Exiting...\n";
        exit 30;
    }
}

exit;

=head1 SUBROUTINES

=cut

=head2 get_master_password( )

Prompt the user for the password to decrypt the secrets file. This is done in
'noecho' mode, so the password doesn't appear on the screen.

Expects:
    None.

Returns:
    String containing the password to decrypt the secrets file.

=cut

sub get_master_password {

    my $master_password = get_user_input( "Please enter master password: ", 'noecho' );

    return $master_password;
}

=head2 print_secret( $secret, $fields )

Prints any set fields of the secret to STDOUT.

Expects:
    A hashref containing the secret data.
    An array ref containing the fields to print.

Returns:
    None.

=cut

sub print_secret {
    my $secret = shift;
    my $fields = shift;


    print "\n$secret->{name}\n", "=" x length($secret->{name}), "\n";
    foreach my $field ( @{ $fields } ) {
        $secret->{lc $field} && print "$field: $secret->{lc $field}\n";
    }
    print "\n";
}

=head2 get_secret_by_name( $secret_name, $secrets )

Expects:
    The full name of a secret.
    The set of all secrets.

Returns:
    The secret matching the canonical version of $secret_name if it exists.
    Else undef

=cut

sub get_secret_by_name {
    my $secret_name = shift;
    my $secrets     = shift;

    my $canonical_name = get_canonical_name($secret_name);

    return $secrets->{$canonical_name};
}

=head2 get_secret_name( )

Expects:
    A string representing the action the user is planning.

Returns:
    The name of a secret to operate on.

=cut

sub get_secret_name {
    my $action = shift;

    my $secret_name = get_user_input("Which secret do you wish to $action? ");

    return $secret_name;
}

=head2 get_secret_fields( )

Prompt the user for the required and optional data which make up a secret.

Expects:
    An array ref of field names.
    An optional secret.

Returns:
    Valid secret hash or undef.

=cut

sub get_secret_fields {
    my $fields = shift;
    my $secret = shift || {};

    foreach my $field ( @{ $fields } ) {
        if ( $secret->{lc $field} ) {
            # Show the previous value, and reuse it if the user just hits enter.
            my $new_value = get_user_input("$field [" . $secret->{lc $field} . "]: ");
            $secret->{lc $field} = length $new_value ? $new_value : $secret->{lc $field};
        }  
        else {
            $secret->{lc $field} = get_user_input("$field: ");
        }
    }
    $secret->{canonical_name} = get_canonical_name( $secret->{name} );

    return $secret;
}

=head2 get_canonical_name($name)

Expects:
    Name of a secret.

Returns:
    Lowercased, whitespace-free version of name.

=cut

sub get_canonical_name {
    my $name = shift;

    my $canonical_name = lc $name;
    chomp $canonical_name;
    $canonical_name =~ s{\s+}{_}gxms;

    return $canonical_name;
}

=head2 write_secrets_to_file( $secrets, $secrets_file, $password )

Write the secrets data structure to the secrets file. The data is serialised
then encrypted, then written to disk.

NOTE: This will clobber any existing data in the file, so if you attempt to
write to the file from more then one process simultaneously, the last writer
will win.

TODO: Look at file locking code.

Expects:
    Secrets hash ref.
    Filename to write secrets to.
    Password to encrypt the files contents.

Returns:
    None.

=cut

sub write_secrets_to_file {
    my $secrets      = shift;
    my $secrets_file = shift;
    my $password     = shift;

    my $frozen = Storable::nfreeze($secrets);

    # TODO: Encrypt the frozen data.

    File::Slurp::write_file($secrets_file, {binmode => ':raw'}, $frozen);
}

=head2 read_secrets_from_file( $secrets_file, $password )

Expects:
    Filename to read secrets from.
    Password to decrypt the files contents.

Returns:
    If everything works (file exists, contains data, password works), then an
    hash ref of secrets.
    Else undef.

=cut

sub read_secrets_from_file {
    my $secrets_file = shift;
    my $password     = shift;

    # Case 1: Non-existant file. This is expected for a first run, or when a
    # new secrets filename is passed in.
    return undef unless -f $secrets_file;

    # Case 2: Existing file
    my $frozen = File::Slurp::read_file($secrets_file);
    return undef unless $frozen;

    # TODO: Decryption
    my $secrets = Storable::thaw($frozen);
    return $secrets;

}

=head2 get_user_input( $prompt ) 

Prompt the user for input, optionally hide what they're typing, and chomp any
string entered.

Expects:
    A textual prompt to print. Can be blank.
    A mode of normal|noecho when reading the input.

Returns:
    A chomped string from STDIN

=cut

sub get_user_input {
    my $prompt = shift || '';
    my $mode   = shift || 'normal';

    print $prompt;
    Term::ReadKey::ReadMode($mode);
    my $input = Term::ReadKey::ReadLine(0);
    Term::ReadKey::ReadMode('normal');
    print "\n" if $mode eq 'noecho';

    chomp $input;
    return $input;
}
__END__
